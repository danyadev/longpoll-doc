# User Long Poll API

### План документации:
1. [Подключение](#подключение)
2. [Возвращаемые ошибки](#возвращаемые-ошибки)
3. [Получение истории событий](#получение-истории-событий)
4. [Структура сообщения](#структура-сообщения)
5. [Описание событий](#описание-событий)
   - [Событие 2. Установка флагов сообщения](#событие-2-установка-флагов-сообщения)
   - [Событие 3. Сброс флагов сообщения](#событие-3-сброс-флагов-сообщения)
   - [Событие 4. Новое сообщение](#событие-4-новое-сообщение)
   - [Событие 5. Редактирование сообщения](#событие-5-редактирование-сообщения)
   - [Событие 6. Прочтение входящих сообщений](#событие-6-прочтение-входящих-сообщений)
   - [Событие 7. Прочтение исходящих сообщений](#событие-7-прочтение-исходящих-сообщений)
   - [Событие 8. Друг появился в сети](#событие-8-друг-появился-в-сети)
   - [Событие 9. Друг вышел из сети](#событие-9-друг-вышел-из-сети)
   - [Событие 10. Просмотрено упоминание в беседе](#событие-10-просмотрено-упоминание-в-беседе)
   - [Событие 12. Пришло упоминание в беседе](#событие-12-пришло-упоминание-в-беседе)
   - [Событие 13. Удаление всех сообщений в диалоге](#событие-13-удаление-всех-сообщений-в-диалоге)
   - [Событие 18. Добавление сниппета к сообщению](#событие-18-добавление-сниппета-к-сообщению)
   - [Событие 19. Сброс кеша сообщения](#событие-19-сброс-кеша-сообщения)
   - [Событие 51. Изменение данных чата (не следует использовать)](#событие-51-изменение-данных-чата-не-следует-использовать)
   - [Событие 52. Изменение данных чата](#событие-52-изменение-данных-чата)
   - [Событие 63. Статус набора сообщения](#событие-63-статус-набора-сообщения)
   - [Событие 64. Статус записи голосового сообщения](#событие-64-статус-записи-голосового-сообщения)
   - [Событие 80. Изменение количества непрочитанных диалогов](#событие-80-изменение-количества-непрочитанных-диалогов)
   - [Событие 81. Изменение состояния невидимки друга](#событие-81-изменение-состояния-невидимки-друга)
   - [Событие 114. Изменение настроек пуш-уведомлений в беседе](#событие-114-изменение-настроек-пуш-уведомлений-в-беседе)
   - [Событие 115. Звонок](#событие-115-звонок)
6. [Дополнительные данные](#дополнительные-данные)
   - [Флаги сообщений](#флаги-сообщений)
   - [Сервисные сообщения](#сервисные-сообщения)
   - [Клавиатура для ботов](#клавиатура-для-ботов)
   - [Вложения](#вложения)
   - [Зачем нужен random_id](#зачем-нужен-random_id)

Документация написана для __10__ версии Long Poll.

Последняя версия Long Poll - __12__, но в __11__ версии были удалены события [онлайна](#событие-8-друг-появился-в-сети) и [оффлайна](#событие-9-друг-вышел-из-сети) друга, а в __12__ дублировали поле с флагами сообщения.

Вполне вероятно, что версии выше __10__ были созданы для тестов.

## Подключение

__Long Polling__ - это технология, используемая для получения событий в реальном времени, которая основана на бесконечной цепочке запрос - ответ - запрос... При подаче запроса сервер возвращает ответ не сразу, а когда придет новое событие или истечет время ожидания. Подробнее про данную технологию можно прочитать [здесь](https://learn.javascript.ru/long-polling).

Ссылка для запроса составляется следующим образом:

> https://**`server`**?act=a_check&key=**`key`**&ts=**`ts`**&wait=**`wait`**&mode=**`mode`**&version=**`version`**

* `server`, `key` и `ts` получаются методом [`messages.getLongPollServer`](https://vk.com/dev/messages.getLongPollServer)
* `version` - Версия LongPoll
* `wait` - Время ожидания нового события в секундах, максимум `90`, рекомендую от `10` до `25`
* `mode` - Дополнительные опции ответа:
  * `2` - Возвращать вложения
  * `8` - Возвращать данные в [114](#событие-114-изменение-настроек-пуш-уведомлений-в-беседе) и [115](#событие-115-звонок) событиях
  * `32` - Возвращать `pts`
  * `64` - Возвращать данные о платформе в событии [онлайна друга](#событие-8-друг-появился-в-сети)
  * `128` - Возвращать [`random_id`](#зачем-нужен-random_id)

Настоятельно рекомендую использовать в `mode` все дополнительные опции.

В `Node.js` ссылку можно составить следующим образом:
```js
// server, key и ts нужно получить заранее. 
const link = `https://${server}?` + require('querystring').stringify({
  act: 'a_check',
  key: key,
  ts: ts,
  wait: 10,
  mode: 2 | 8 | 32 | 64 | 128,
  version: 10
});
```

После выполнения запроса сервер вернет ответ следующего вида:
```js
{
  ts?: number,
  pts?: number,
  updates?: any[],
  failed?: 1 | 2 | 3 | 4,
  min_version?: 0,
  max_version?: 12
}
```

После обработки ответа для продолжения работы Long Poll нужно повторить запрос, перед этим заменив `ts` на новый из ответа.

## Возвращаемые ошибки

Иногда вместо поля `updates` в ответе может прийти поле `failed`. Чаще всего приходит `2` ошибка, но могут прийти и другие:

1. Устарела история событий. Решается [получением истории событий](#получение-истории-событий) и использованием переданного `ts` далее.
2. Истекло время действия ключа. Решается получением нового `key` из метода [`messages.getLongPollServer`](https://vk.com/dev/messages.getLongPollServer).
3. Информация о пользователе утрачена. Решается [получением истории событий](#получение-истории-событий) и получением `key` и `ts` из метода [`messages.getLongPollServer`](https://vk.com/dev/messages.getLongPollServer).
4. Передана неправильная версия. В ответе приходят поля `min_version` и `max_version`, которые обозначают минимальную и максимальную версию.

## Получение истории событий

Чтобы получить историю событий, нам необходим `pts`, получение которого включается полем `need_pts: 1` в [`messages.getLongPollServer`](https://vk.com/dev/messages.getLongPollServer) и добавлением в `mode` флага `32` при [выполнении запроса](#подключение).

Для получения истории мы будем использовать метод [`messages.getLongPollHistory`](https://vk.com/dev/messages.getLongPollHistory) с указанием следующих параметров:
- `ts` - Последний полученный `ts` из LongPoll
- `pts` - Последний полученный `pts` из LongPoll
- `msgs_limit` - Максимальное количество передаваемых сообщений. Минимум `200`, рекомендую `500`
- `max_msg_id` - `id` последнего полученного сообщения из LongPoll
- `onlines` - `1` если возвращать события `8` и `9` ([онлайн](#событие-8-друг-появился-в-сети) и [оффлайн](#событие-9-друг-вышел-из-сети) друга), `0` если нет
- `lp_version` - Версия LongPoll
- `fields` - Поля [пользователей и групп](https://vk.com/dev/objects/user), которые могут прийти вместе с историей

Ответ выглядит следующим образом:
```js
{
  // Здесь содержатся некоторые события из LongPoll,
  // но вся информация действительно является только числами:
  // [event_id, msg_id, flag, peer_id] или что-то похожее
  history: number[][]
  from_pts: number
  new_pts: number
  conversations: Conversation[]
  messages: {
    count: number
    items: Message[]
  }
  profiles?: BaseUser[]
  groups?: BaseGroup[]
  more?: true
}
```

Поле `history` идентично полю `updates`, которое приходит из Long Poll, за исключением удаления некоторых лишних событий (т.к. приходит просто измененный объект беседы или сообщения) и сокращения некоторых событий:
- `3` - [Сброс флагов сообщения](#событие-3-сброс-флагов-сообщения)
- `4` - [Новое сообщение](#событие-4-новое-сообщение)
- `5` - [Редактирование сообщения](#событие-5-редактирование-сообщения)
- `18` - [Добавление сниппета к сообщению](#событие-18-добавление-сниппета-к-сообщению)

Структура этих событий выглядит так:
```
[event_id, msg_id, flags, peer_id]
```

Остальная информация о сообщениях находится в полях `messages` и `conversations` и уже содержит всю информацию о сообщении,
то есть структура уже из API, а не из LongPoll.

Если в ответе придет поле `more`, то после обработки всех событий нужно будет повторить запрос, указав в поле `pts` пришедший `new_pts`, а в поле `max_msg_id` `id` последнего полученного отсюда сообщения.

## Структура сообщения

Структура сообщения встречается сразу в 4 событиях ([`3`](#событие-3-сброс-флагов-сообщения), [`4`](#событие-4-новое-сообщение), [`5`](#событие-5-редактирование-сообщения) и [`18`](#событие-18-добавление-сниппета-к-сообщению)), поэтому было решено описать ее отдельно.

В данной структуре есть еще несколько структур, которые описаны в других частях документации:

- [Флаги сообщений](#флаги-сообщений)
- [Шаблоны](https://vk.com/dev/bot_docs_templates?f=5.%2B%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B%2B%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B9)
- [Клавиатура для ботов](#клавиатура-для-ботов)
- [Сервисные сообщения](#сервисные-сообщения)
- [Вложения](#вложения)
- [random_id](#зачем-нужен-random_id)

```js
[
  event_id: 3 | 4 | 5 | 18,
  msg_id: number,
  flags: number,
  peer_id: number,
  timestamp: number,
  text: string,
  {
    // Приходит только в лс | в каналах
    title?: ' ... ' | ''
    // Наличие emoji
    emoji?: '1'
    // id автора сообщения. Приходит только в беседах
    from?: string
    // Наличие шаблона (для получения шаблона нужно получить сообщение из API)
    has_template?: '1'
    // 1:
    // number[]: Список упомянутых людей прямо или через @online или ответ на сообщение от [user_id]
    // 'all': @all
    // 2: Исчезающее сообщение в лс и обычном чате (т.е. не приходит в фантомных чатах)
    marked_users?: [
      | [1, number[] | 'all']
      | [2, 'all']
    ]
    // Клавиатура для ботов (в т.ч. инлайн)
    keyboard?: MessageKeyboard
    // Сообщение исчезло, приходит в 18 событии
    is_expired?: '1'
    // Сервисное сообщение
    ...action
  },
  {
    // Есть пересланное сообщение или ответ на сообщение
    fwd?: '0_0'
    // Есть ответ на сообщение; "{"conversation_message_id":NUMBER}"
    reply?: string

    // Видимо только началась разработка выдачи вложений прямо в LongPoll,
    // поэтому эти поля приходят пока что только для стикеров
    // Число в строке
    attachments_count?: string
    // JSON с массивом вложений
    attachments?: string
    // Описание вложений вида { attach1_type, attach1, ... }
    ...attachments
  },
  random_id: number, // Возвращается, если в mode есть флаг 128
  conversation_message_id: number, // id сообщения относительно беседы
  edit_time: number // 0 (не редактировалось) или timestamp (время редактирования)
]
```

Стоит отметить, что в поле `text` переносы строк обозначаются как `<br>`, а символы `"`, `&`, `<` и `>` экранируются.

## Описание событий

### Событие 2. Установка флагов сообщения

Структура: `[2, msg_id, flags, peer_id]`

Возможные значения [флагов сообщения](#флаги-сообщений):
1. Пометка важным (`important`)
2. Пометка как спам (`spam`)
3. Удаление сообщения (`deleted`)
4. Удаление для всех (`deleted` и `deleted_all`)
5. Прослушка голосового сообщения (`audio_listened`)

### Событие 3. Сброс флагов сообщения

Возможные значения [флагов сообщения](#флаги-сообщений):
1. Прочитано сообщение (`unread`). Не рекомендую использовать, потому что иногда этот флаг не приходит
2. Отмена пометки важным (`important`)
3. Отмена пометки сообщения как спам (`spam` и `cancel_spam`)
4. Восстановление удаленного сообщения (`deleted`)

В 1 и 2 случаях структура у события такая: `[2, msg_id, flags, peer_id]`.  
В 3 и 4 случаях возвращается [сообщение](#структура-сообщения).

### Событие 4. Новое сообщение

Данное событие возвращает новое [сообщение](#структура-сообщения).

### Событие 5. Редактирование сообщения

Данное событие возвращает отредактированное [сообщение](#структура-сообщения).

### Событие 6. Прочтение входящих сообщений

Структура: `[6, peer_id, msg_id, count]`

Вы прочитали в диалоге `peer_id` сообщения до `msg_id` включительно.  
`count` - количество непрочитанных в диалоге сообщений.

### Событие 7. Прочтение исходящих сообщений

Структура: `[7, peer_id, msg_id, count]`

Собеседник прочитал в диалоге `peer_id` сообщения до `msg_id` включительно.  
`count` - количество непрочитанных в диалоге __ваших__ сообщений.

### Событие 8. Друг появился в сети

Структура: `[8, -user_id, platform, timestamp, app_id]`
- `user_id` - `id` друга
- `platform` - Тип устройства, с которого онлайн друг:
   - `1` - `m.vk.com` или неизвестное мобильное приложение
   - `2` - iPhone
   - `3` - iPad
   - `4` - Android
   - `5` - windows Phone
   - `6` - Windows 8
   - `7` - `vk.com` или неизвестное десктопное приложение
- `timestamp` - Время онлайна в секундах
- `app_id` - `id` приложения, с которого онлайн друг

### Событие 9. Друг вышел из сети

Структура: `[9, -user_id, isTimeout, timestamp, app_id]`
- `user_id` - `id` друга
- `isTimeout` - `1` если бездействовал 5 минут, `0` если покинул сайт
- `timestamp` - Время наступления оффлайна в секундах
- `app_id` - `id` приложения, с которого был онлайн друг

### Событие 10. Просмотрено упоминание в беседе

__Примечание__: Описание данного события может быть неточным или вовсе неверным

Структура: `[10, peer_id, flags]`

Приходит при просмотре своего упоминания в беседе `peer_id`.

### Событие 12. Пришло упоминание в беседе

__Примечание__: Описание данного события может быть неточным или вовсе неверным

Структура: `[12, peer_id, flags]`

Приходит, когда вас упоминают или отвечают на ваше сообщение в беседе `peer_id`.

### Событие 13. Удаление всех сообщений в диалоге

Структура: `[13, peer_id, last_msg_id]`
- `peer_id` - Диалог, в котором были удалены все сообщения
- `last_msg_id` - `id` последнего сообщения в беседе (т.е. были удалены все сообщения до `last_msg_id` включительно)

### Событие 18. Добавление сниппета к сообщению

Данное событие возвращает [сообщение](#структура-сообщения) с добавленным вложением типа `link`.

### Событие 19. Сброс кеша сообщения

Структура: `[19, msg_id]`

Сообщение по какой-то причине изменилось.  
Если сообщение есть в кеше, то нужно его переполучить через API.

### Событие 51. Изменение данных чата (не следует использовать)

Структура: `[51, chat_id]`

Событие означает, что в беседе `chat_id` изменились какие-то данные.
Более подробно все расписано в [52 событии](#событие-52-изменение-данных-чата).

### Событие 52. Изменение данных чата

Структура: `[52, type, peer_id, extra]`
- `peer_id` - `id` беседы, в которой произошло событие
- `extra` - Дополнительная информация, которая зависит от `type`
- `type` - Тип действия:
   - `1` - Изменилось название беседы
      - Основная информация приходит в [сервисном сообщении](#сервисные-сообщения) в [4 событии](#событие-4-новое-сообщение)
      - `extra` = `0`
   - `2` - Обновилась аватарка беседы
      - Основная информация приходит в [сервисном сообщении](#сервисные-сообщения) в [4 событии](#событие-4-новое-сообщение)
      - `extra` = `0`
   - `3` - Назначен новый администратор
      - `extra` = `id` нового администратора
   - `4` - Изменение прав в беседе  
      Поле `extra` является маской, которая может включать следующие флаги:
      - `1` - Приглашать участников в беседу могут только администраторы
      - `2` - Неизвестно
      - `4` - Менять закрепленное сообщение могут только администраторы
      - `8` - Редактировать информацию беседы (фото, название) могут только администраторы
      - `16` - Добавлять администраторов кроме создателя могут и другие администраторы
   - `5` - Закрепление или открепление сообщения
      - `extra` = `conversation_message_id` сообщения при закреплении и `0` при откреплении
   - `6` - Вступление в беседу (по ссылке, приглашение или возвращение в беседу)
      - `extra` = `id` добавленного юзера
   - `7` - Выход из беседы
      - `extra` = `id` вышедшего из беседы
   - `8` - Исключение из беседы
      - `extra` = `id` исключенного из беседы
   - `9` - Разжалован администратор
      - `extra` = `id` разжалованного из администраторов
   - `11` - Появление и скрытие клавиатуры
      - `extra` = `id` диалога, в котором произошло действие

### Событие 63. Статус набора сообщения

Структура: `[63, peer_id, [from_ids], from_ids_count, timestamp]`

Означает, что в беседе `peer_id` начали писать текст `from_ids_count` людей. Их `id` записаны в `from_ids`.  
В массиве `from_ids` может быть и ваш `id`, так что перед отображением стоит проверить и удалить свой `id`.

### Событие 64. Статус записи голосового сообщения

Идентичен [событию 63](#событие-63-статус-набора-сообщения), но вызывается в случае записи голосового сообщения, а не при наборе текста.

### Событие 80. Изменение количества непрочитанных диалогов

Структура: `[80, count, count_with_notifications]`
- `count` - Количество непрочитанных диалогов
- `count_with_notifications` - Количество непрочитанных сообщений со включенными уведомлениями

### Событие 81. Изменение состояния невидимки друга

Структура: `[-user_id, state, timestamp]`
- `user_id` - `id` друга
- `state` - `1` если включена, `0` если выключена
- `timestamp` - время совершения действия

### Событие 114. Изменение настроек пуш-уведомлений в беседе

Структура: `[{ peer_id, sound, disabled_until }]`
- `peer_id` - `id` беседы, в которой включили или выключили уведомления
- `sound` - нестабильный параметр, не рекомендую его обрабатывать
- `disabled_until` может быть трех видов:
   - `0` - Включены
   - `-1` - Выключены
   - `Number, > 0`, - Выключены, время их включения

### Событие 115. Звонок

¯\\\_(ツ)\_/¯

## Дополнительные данные

### Флаги сообщений

Маской называют сумму некоторых флагов (степеней двойки), которую можно использовать как хорошую замену для обьектов или массивов.

```js
// Обычно маску записывают подобным образом: 
const mask = 1 | 2 | 8 | 64 | 1024 | 1 << 11 | 1 << 15;

// Но можно и так:
// Скобки необходимы, потому что у "+" приоритет выше чем у "<<"
const mask = 1 + 2 + 8 + 64 + 1024 + (1 << 11) + (1 << 15);

// Хотя новички могут записывать всю маску целиком и не понимать что она делает:
const mask = 35915;
```

Для того, чтобы не запутаться в больших значениях степеней двойки,
можно использовать `1 << n`, что означает `2` в степени `n`.

|    Название    |                 Описание                 |  Значение  |
| :------------: | :--------------------------------------: | :--------: |
| unread         | Непрочитанное сообщение                  | `1 << 0`   |
| outbox         | Исходящее сообщение                      | `1 << 1`   |
| important      | Важное сообщение                         | `1 << 3`   |
| chat           | Отправка сообщения в беседу через vk.com | `1 << 4`   |
| friends        | Исходящее; входящее от друга в лс        | `1 << 5`   |
| spam           | Пометка сообщения как спам               | `1 << 6`   |
| deleted        | Удаление сообщения локально              | `1 << 7`   |
| audio_listened | Прослушано голосовое сообщение           | `1 << 12`  |
| chat2          | Отправка в беседу через клиенты          | `1 << 13`  |
| cancel_spam    | Отмена пометки как спам                  | `1 << 15`  |
| hidden         | Приветственное сообщение от группы       | `1 << 16`  |
| deleted_all    | Удаление сообщения для всех              | `1 << 17`  |
| chat_in        | Входящее сообщение в беседе              | `1 << 19`  |
| silent         | "Бесшумное" сообщение (без уведомления)  | `1 << 20`  |
| reply_msg      | Ответ на сообщение                       | `1 << 21`  |

Бесшумное сообщение можно отправить, добавив к параметрам метода [`messages.send`](https://vk.com/dev/messages.send) ключ `silent: true`:
- Такое сообщение отправится без уведомления пользователю, даже если у него включены уведомления
- Упоминание или ответ на сообщение тоже не отправит уведомления
- Сообщение о выходе из беседы автоматически приходит без уведомления

Пример определения наличия флага в маске:
```js
const mask = 1 | 2 | 32;

8 & mask // вернет 0 (false)
2 & mask // вернет 2 (true)
```

### Сервисные сообщения

Сервисное сообщение описывается ключем `source_act` и ключами с дополнительными данными.

Возможные значения `source_act`:
- __`chat_create`__ - Создание беседы
   - `source_text` - Название беседы
- __`chat_photo_update`__ - Обновление фотографии беседы
   - Нет дополнительных ключей, но добавляет фотографию во вложениях
- __`chat_photo_remove`__ - Удаление фотографии беседы
   - Нет дополнительных ключей
- __`chat_title_update`__ - Обновление название беседы
   - `source_old_text` - Старое название беседы (но при полчении сообщения из API его не будет)
   - `source_text` - Новое название беседы
- __`chat_pin_message`__ - Закрепление сообщения
   - `source_mid` - `id` закрепившего сообщение
   - `source_message` - обрезанное закрепляемое сообщение
   - `source_chat_local_id` - `conversation_message_id` закрепляемого сообщения
- __`chat_unpin_message`__ - Открепление сообщения
   - `source_mid` - `id` открепившего сообщение
   - `source_chat_local_id` - `conversation_message_id` открепляемого сообщения
- __`chat_invite_user`__ - Вступление или возвращение в беседу
   - `source_mid` - `id` вступившего или вернувшегося
   - Если `source_mid` совпадает с `from`, то он вернулся сам, иначе - его пригласили
- __`chat_invite_user_by_link`__ - Вступление по ссылке
   - Нет дополнительных ключей
- __`chat_kick_user`__ - Исключение или выход из беседы
   - `source_mid` - `id` кикнутого или вышедшего
   - если `source_mid` совпадает с `from`, то он вышел сам, иначе - его кикнули
- __`chat_screenshot`__ - Создание скриншота с фантомным сообщением
   - `source_mid` - `id` создавшего скриншот

Пример описания сервисного сообщения:
```js
{
  source_act: 'chat_pin_message',
  source_mid: '88262293',
  source_message: 'Сообщение, которое будет в закрепе',
  source_chat_local_id: '5517'
}
```

### Клавиатура для ботов

Клавиатура для ботов представляет собой обьект с описанием ее типа и кнопок.
Основная структура представлена ниже, остальную информацию можно узнать в [документации](https://vk.com/dev/bots_docs_3?f=4.2.%20%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85).
```js
{
  // Клавиатура для сообщения или для беседы
  inline?: true
  // Скрывать ли клавиатуру при клике на кнопку (не работает для inline)
  one_time: boolean
  buttons?: KeyboardButton[][]
}
```

### Вложения

__Хорошие новости:__ ВКонтакте, кажется, уже начал тестировать новый формат возвращения вложений - прямиком объект вложения как в API. На данный момент я заметил это только для стикеров, но возможно в будущем все вложения будут приходить в нормальном виде.

Список известных на данный момент вложений: `geo`, `doc`, `link`, `poll`, `wall`, `call`, `gift`, `story`, `photo`, `audio`, `video`, `event`, `market`, `artist`, `sticker`, `article`, `podcast`, `graffiti`, `wall_reply`, `audio_message`, `money_request`, `audio_playlist`.

Однако названия вложений, полученных через LongPoll, могут не совпадать с теми, что приходят через API:
- `event`, приходящий в API, в LongPoll обозначается как `group`
- `audio_message` и `graffiti` из LongPoll обозначаются как `doc`, но при этом добавляется ключ `attach*_kind` в ответе вложения со значением `audiomsg` или `graffiti`
- `artist`, `audio_playlist` и `article`, которые приходят в LongPoll, через API отображаются как `link`

Вложение `geo` (прикрепленное местоположение) является еще одним исключением и приходит не как `attach*`, а просто как ключи `geo` и иногда `geo_provider`. Также при получении сообщения через [`messages.geyById`](https://vk.com/dev/messages.getById) ключ `geo` будет находиться не во вложениях, а в "корне" сообщения.

На данный момент вложения передаются достаточно неудобным для обработки способом. Вот пример вложений, состоящих из фотографии, документа и аудиозаписи:
```js
{
  attach1: '88262293_457290160',
  attach1_type: 'photo',
  attach2: '88262293_532324610',
  attach2_type: 'doc',
  attach3: '88262293_535133534',
  attach3_kind: 'audiomsg',
  attach3_type: 'doc'
}
```

Для того, чтобы вытащить их названия нужно писать дополнительный код. Однако вытаскивать идентификаторы вложений нет смысла, потому что они не представляют никакой ценности. Чтобы получить нормальную информацию о вложениях, нужно получить сообщение через API, используя метод [`messages.geyById`](https://vk.com/dev/messages.getById). Пример кода для получения массива с названиями вложений на `JavaScript`:
```js
function getAttachments(data) {
  const attachments = [];

  if (data.geo) {
   attachments.push({ type: 'geo' });
  }

  for (const key in data) {
    const match = key.match(/attach(\d+)$/);

    if (match) {
      const id = match[1];
      const kind = data[`attach${id}_kind`];
      let type = data[`attach${id}_type`];

      if (kind === 'audiomsg') type = 'audio_message';
      if (kind === 'graffiti') type = 'graffiti';
      if (type === 'group') type = 'event';

      attachments.push({ type });
    }
  }

  return attachments;
}
```

При работе с вложениями можно попробовать найти необходимый элемент в [документации](https://vk.com/dev/objects), однако у некоторых вложений документация не обновлена или вовсе отсутствует.

### Зачем нужен random_id

Начнем с того, что `random_id` начиная с версии API `5.90` стал обязательным параметром.
Но это не означает, что всем нужно генерировать уникальные значения для этого параметра.
Если вы его не собираетесь использовать, то можете указать в его значении число `0`.

Значение `random_id` должно быть уникальным в течение __одного часа__ в рамках `app_id`, `id` пользователя и `peer_id` диалога.

Значение `random_id` может принимать числа от `-2147483648` (`-(2^31)`) до `2147483647` (`2^31 - 1`).
Если число будет больше или меньше данного порога, то из переданного числа отнимется этот лимит.

В документации написано, что `random_id` необходим для того, чтобы предотвратить повторную отправку одинакового сообщения.
Однако это не единственное возможное применение данного параметра.

Наверняка вы уже видели, что во всех мессенджерах ВКонтакте при отправке сообщения само сообщение отображается сразу,
но около сообщения некоторое время видно иконку часов. Эта иконка означает, что сообщение еще не пришло обратно через LongPoll.

Чтобы реализовать подобную фичу, нужно определить, какое именно сообщение, приходящее из LongPoll, было только что отправлено.
Для этого нужно:
1) Создать `random_id` и сохранить его в списке с загружаемыми сообщениями
2) Отправить сообщение
3) Дождаться прихода из LongPoll сообщения с нашим `random_id`
4) Удалить `random_id` из списка, тем самым пометив сообщение как загруженное.
